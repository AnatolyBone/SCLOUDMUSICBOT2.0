import { T, loadTexts } from './config/texts.js'; // –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —ç—Ç–æ—Ç –∏–º–ø–æ—Ä—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π

async function setupTelegramBot() {
  bot.start(async (ctx) => {
    try {
      const user = ctx.state.user || await getUser(ctx.from.id, ctx.from.first_name, ctx.from.username);
      const messageText = formatMenuMessage(user, ctx);
      await ctx.reply(messageText, { reply_markup: getBonusKeyboard(user) }); // parse_mode —É–±—Ä–∞–Ω
      await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:', kb());
    } catch (e) {
      await handleSendMessageError(e, ctx.from.id);
    }
  });

  bot.hears(T('menu'), async (ctx) => {
    try {
      const user = ctx.state.user || await getUser(ctx.from.id);
      const messageText = formatMenuMessage(user, ctx);
      await ctx.reply(messageText, { reply_markup: getBonusKeyboard(user) }); // parse_mode —É–±—Ä–∞–Ω
    } catch (e) {
      await handleSendMessageError(e, ctx.from.id);
    }
  });

  bot.hears(T('mytracks'), async (ctx) => {
    try {
      const user = ctx.state.user || await getUser(ctx.from.id);
      let tracks = [];
      if (Array.isArray(user.tracks_today)) {
        tracks = user.tracks_today;
      } else if (typeof user.tracks_today === 'string') {
        try { tracks = JSON.parse(user.tracks_today); } catch { tracks = []; }
      }
      const validTracks = tracks.filter(t => t && t.fileId);
      if (!validTracks.length) {
        return await ctx.reply(T('noTracks') || '–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Ç—Ä–µ–∫–æ–≤ –∑–∞ —Å–µ–≥–æ–¥–Ω—è.');
      }
      for (let i = 0; i < validTracks.length; i += 5) {
        const chunk = validTracks.slice(i, i + 5);
        await ctx.replyWithMediaGroup(chunk.map(track => ({ type: 'audio', media: track.fileId, title: track.title })));
      }
    } catch (err) {
      console.error('–û—à–∏–±–∫–∞ –≤ /mytracks:', err);
      await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç—Ä–µ–∫–æ–≤.');
    }
  });

  bot.hears(T('help'), async (ctx) => {
    try { 
      await ctx.reply(T('helpInfo'), kb());
    } catch (e) {
      await handleSendMessageError(e, ctx.from.id);
    }
  });

  bot.hears(T('upgrade'), async (ctx) => {
    try {
      // –£–±–∏—Ä–∞–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
      await ctx.reply(T('upgradeInfo').replace(/\*/g, ''));
    } catch (e) {
      await handleSendMessageError(e, ctx.from.id);
    }
  });

  bot.command('admin', async (ctx) => {
    if (ctx.from.id !== Number(process.env.ADMIN_ID)) return;
    try {
      const users = await getAllUsers(true);
      const totalUsers = users.length;
      const activeUsers = users.filter(u => u.active).length;
      const totalDownloads = users.reduce((sum, u) => sum + (u.total_downloads || 0), 0);
      const now = new Date();
      const activeToday = users.filter(u => u.last_active && new Date(u.last_active).toDateString() === now.toDateString()).length;

      const dashboardUrl = `${WEBHOOK_URL.replace(/\/$/, '')}/dashboard`;

      const message = `
        üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ë–æ—Ç–∞</b>
        üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b>
           - –í—Å–µ–≥–æ: <i>${totalUsers}</i>
           - –ê–∫—Ç–∏–≤–Ω—ã—Ö –≤—Å–µ–≥–æ: <i>${activeUsers}</i>
           - –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: <i>${activeToday}</i>
        üì• <b>–ó–∞–≥—Ä—É–∑–∫–∏:</b>
           - –í—Å–µ–≥–æ –∑–∞ –≤—Å–µ –≤—Ä–µ–º—è: <i>${totalDownloads}</i>
        ‚öôÔ∏è <b>–û—á–µ—Ä–µ–¥—å —Å–µ–π—á–∞—Å:</b>
           - –í —Ä–∞–±–æ—Ç–µ: <i>${downloadQueue.active}</i>
           - –í –æ–∂–∏–¥–∞–Ω–∏–∏: <i>${downloadQueue.size}</i>
        üîó <a href="${dashboardUrl}">–û—Ç–∫—Ä—ã—Ç—å –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</a>
      `;
      
      await ctx.replyWithHTML(message.trim());
    } catch (e) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ /admin:', e);
      try {
        await ctx.reply('‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.');
      } catch {}
    }
  });

  bot.on('text', async (ctx) => {
    try {
      const url = extractUrl(ctx.message.text);
      if (url) {
        await enqueue(ctx, ctx.from.id, url);
      } else if (![T('menu'), T('upgrade'), T('mytracks'), T('help')].includes(ctx.message.text)) {
        await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ –∏–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç SoundCloud.');
      }
    } catch (e) {
      await handleSendMessageError(e, ctx.from.id);
    }
  });
}

export { setupTelegramBot };