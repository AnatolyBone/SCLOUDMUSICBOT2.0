import ytdl from 'youtube-dl-exec';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { enqueue, processNextInQueue } from '../queue/downloadQueue.js';
import { incrementDownloads, resetDailyLimitIfNeeded, saveTrackForUser } from '../db/trackRepository.js';
import { getUser, updateUserField } from '../db/userRepository.js';
import { logDownload, logEvent } from '../db/logRepository.js';
import { safeTelegramCall } from '../utils/telegramUtils.js';
import { sanitizeFilename } from '../utils/fileUtils.js';
import { resolveRedirect } from '../utils/networkUtils.js';
import { texts, sendAudioSafe } from './botUtils.js';
import NodeID3 from 'node-id3';
import util from 'util';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const cacheDir = path.join(__dirname, '../../cache');

const writeID3 = util.promisify(NodeID3.write);

export { enqueue }; // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º enqueue –∏–∑ downloadQueue

// –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º processNextInQueue –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç—Ä–µ–∫–æ–≤
// –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å—Å—è –∏–∑ downloadQueue.js
export async function processTrackByUrl(ctx, userId, url) {
  let user;
  try {
    user = await getUser(userId);
    if (!user) {
      console.error(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
      await ctx.telegram.sendMessage(userId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.');
      return;
    }

    await resetDailyLimitIfNeeded(userId);

    if (user.downloads_today >= user.premium_limit) {
      await ctx.telegram.sendMessage(userId, texts.limitReached);
      await logEvent(userId, 'limit_reached');
      return;
    }

    await logEvent(userId, 'download_started', { url });
    await ctx.telegram.sendMessage(userId, texts.downloading);

    const resolvedUrl = await resolveRedirect(url);

    const info = await ytdl(resolvedUrl, {
      dumpSingleJson: true,
      noCheckCertificates: true,
      noWarnings: true,
      callHome: false,
      preferFreeFormats: true,
      youtubeSkipDashManifest: true,
      referer: resolvedUrl,
    });

    const title = sanitizeFilename(info.title || 'audio');
    const filePath = path.join(cacheDir, `${title}.mp3`);

    await ytdl(resolvedUrl, {
      output: filePath,
      extractAudio: true,
      audioFormat: 'mp3',
      noCheckCertificates: true,
      noWarnings: true,
      callHome: false,
      preferFreeFormats: true,
      youtubeSkipDashManifest: true,
      referer: resolvedUrl,
    });

    // –î–æ–±–∞–≤–ª—è–µ–º ID3 —Ç–µ–≥–∏
    await writeID3({
      title: info.title,
      artist: info.artist || info.uploader || 'Unknown',
      album: info.album || 'SoundCloud',
      year: info.upload_date ? info.upload_date.substring(0, 4) : '',
      comment: { text: `Downloaded from SoundCloud via Telegram bot. Original URL: ${resolvedUrl}` }
    }, filePath);

    const fileId = await sendAudioSafe(ctx, userId, filePath, title);

    if (fileId) {
      await incrementDownloads(userId);
      await saveTrackForUser(userId, title, fileId);
      await logDownload(userId, title, fileId);
    } else {
      await ctx.telegram.sendMessage(userId, texts.error);
      await logEvent(userId, 'download_failed', { url, reason: 'send_audio_failed' });
    }

    fs.unlink(filePath, err => {
      if (err) console.error(`–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞ ${filePath}:`, err);
      else console.log(`üóë –£–¥–∞–ª—ë–Ω —Ñ–∞–π–ª: ${filePath}`);
    });
  } catch (e) {
    console.error(`–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç—Ä–µ–∫–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId} (${url}):`, e);
    await ctx.telegram.sendMessage(userId, texts.error);
    await logEvent(userId, 'download_failed', { url, reason: e.message });
  }
}

// –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º processNextInQueue –≤ downloadQueue.js, —á—Ç–æ–±—ã –æ–Ω–∞ –≤—ã–∑—ã–≤–∞–ª–∞ processTrackByUrl
// –≠—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –≤ downloadQueue.js, –Ω–æ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∑–¥–µ—Å—å
// –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ downloadQueue.js –¥–æ–ª–∂–µ–Ω –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å processTrackByUrl
// –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–µ –≤ —Å–≤–æ–µ–π –ª–æ–≥–∏–∫–µ processNextInQueue
// –ü—Ä–∏–º–µ—Ä: downloadQueue.js
/*
import { processTrackByUrl } from '../bot/trackProcessor.js';

export async function processNextInQueue() {
  if (globalQueue.length === 0 || activeDownloads >= MAX_CONCURRENT_DOWNLOADS) {
    return;
  }

  activeDownloads++;
  const { ctx, userId, url, resolve, reject } = globalQueue.shift();

  try {
    await ctx.reply(`‚è≥ –¢—Ä–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ—á–µ—Ä–µ–¥—å (#${globalQueue.length + 1})`);
    await processTrackByUrl(ctx, userId, url); // –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç—Ä–µ–∫–∞
    resolve();
  } catch (error) {
    reject(error);
  } finally {
    activeDownloads--;
    processNextInQueue();
  }
}
*/
